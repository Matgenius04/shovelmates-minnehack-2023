use std::ops::Deref;
use std::{any::type_name, marker::PhantomData, sync::Arc};

use crate::errors::Error;

use log::{info, trace};
use ouroboros::self_referencing;
use rkyv::ser::serializers::AllocSerializer;
use rkyv::{Archive, Deserialize, Fallible};
use sha3::Digest;
use sled::transaction::{
    ConflictableTransactionError, ConflictableTransactionResult, TransactionResult,
    TransactionalTree,
};
use sled::IVec;
use sled::Transactional as SledTransactional;

pub struct Db<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive>(
    Arc<sled::Tree>,
    PhantomData<T>,
);

pub struct Transaction<'a, const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive>(
    &'a TransactionalTree,
    PhantomData<T>,
);

impl<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive> Clone for Db<N, T> {
    fn clone(&self) -> Self {
        Db(Arc::clone(&self.0), PhantomData)
    }
}

fn serialize<const N: usize, T: rkyv::Serialize<AllocSerializer<N>>>(v: &T) -> Result<IVec, Error> {
    let mut serialized = rkyv::to_bytes(v).map_err(Error::unexpected)?;
    serialized.extend_from_slice(&sha3::Sha3_256::digest(&serialized));

    Ok(IVec::from(&*serialized))
}

#[self_referencing]
pub struct Archived<T: Archive>
where
    T::Archived: 'static,
{
    bytes: IVec,
    // I think ouroboros removes `data` from the declaration
    phantom: PhantomData<T>,
    #[borrows(bytes)]
    data: &'this T::Archived,
}

impl<T: Archive> Deref for Archived<T>
where
    T::Archived: 'static,
{
    type Target = T::Archived;

    fn deref(&self) -> &T::Archived {
        self.borrow_data()
    }
}

impl<T: Archive> Archived<T>
where
    T::Archived: 'static,
{
    fn deserialize(bytes: IVec) -> Result<Self, Error> {
        Archived::try_new(bytes, PhantomData, |bytes| {
            let len = bytes.len();
            let hash = bytes
                .get((len - 32)..len)
                .ok_or_else(|| Error::msg("The data in storage is too short to contain a hash"))?;
            let data = bytes.get(0..(len - 32)).ok_or_else(|| {
                Error::msg("The data in storage is too short to contain the data")
            })?;

            if hash != &*sha3::Sha3_256::digest(data) {
                return Err(Error::msg("The hash doesn't match the data"));
            }

            // SAFETY: The data was validated using sha3. This would break if the data was generated by something other than the `serialize` function above, I don't think that's likely
            Ok(unsafe { rkyv::util::archived_root::<T>(data) })
        })
    }

    pub fn to_original_with<D: Fallible + ?Sized>(&self, de: &mut D) -> Result<T, D::Error>
    where
        T::Archived: Deserialize<T, D>,
    {
        self.deref().deserialize(de)
    }

    pub fn to_original(&self) -> T
    where
        T::Archived: Deserialize<T, rkyv::Infallible>,
    {
        self.deref().deserialize(&mut rkyv::Infallible).unwrap()
    }
}

impl<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive> Db<N, T> {
    pub fn open(db: &sled::Db, string: &str) -> Db<N, T> {
        info!("Opening {} DB from {string}", type_name::<T>());

        Db(
            Arc::new(db.open_tree(string).expect("the database to be available")),
            PhantomData,
        )
    }

    pub fn get(&self, key: &str) -> Result<Option<Archived<T>>, Error> {
        trace!("Getting `{key}` from the {} database", type_name::<T>());

        match self.0.get(key).map_err(Error::unexpected)? {
            Some(v) => Ok(Some(Archived::deserialize(v)?)),
            None => Ok(None),
        }
    }

    pub fn iter(&self) -> impl Iterator<Item = Result<(String, Archived<T>), Error>> {
        trace!("Iterating the {} database", type_name::<T>());

        self.0.iter().map(|maybe_v| {
            let (key, val) = maybe_v.map_err(Error::unexpected)?;

            let str = String::from_utf8(key.to_vec()).map_err(Error::unexpected)?;
            let t = Archived::deserialize(val)?;

            Ok((str, t))
        })
    }
}

pub trait Transactional {
    type View<'a>;

    fn transaction<A, F>(&self, f: F) -> TransactionResult<A, Error>
    where
        F: for<'a> Fn(Self::View<'a>) -> ConflictableTransactionResult<A, Error>;
}

impl<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive> Transactional for Db<N, T> {
    type View<'a> = Transaction<'a, N, T>;

    fn transaction<A, F>(&self, f: F) -> TransactionResult<A, Error>
    where
        F: for<'a> Fn(Self::View<'a>) -> ConflictableTransactionResult<A, Error>,
    {
        self.0.transaction(|t| {
            let transaction = Transaction(t, PhantomData);

            f(transaction)
        })
    }
}

impl<
        const N1: usize,
        T1: rkyv::Serialize<AllocSerializer<N1>> + Archive,
        const N2: usize,
        T2: rkyv::Serialize<AllocSerializer<N2>> + Archive,
    > Transactional for (&Db<N1, T1>, &Db<N2, T2>)
{
    type View<'a> = (Transaction<'a, N1, T1>, Transaction<'a, N2, T2>);

    fn transaction<A, F>(&self, f: F) -> TransactionResult<A, Error>
    where
        F: for<'a> Fn(Self::View<'a>) -> ConflictableTransactionResult<A, Error>,
    {
        (&*self.0 .0, &*self.1 .0).transaction(|(t1, t2)| {
            let transaction = (Transaction(t1, PhantomData), Transaction(t2, PhantomData));

            f(transaction)
        })
    }
}

impl<'a, const N: usize, T: rkyv::Serialize<AllocSerializer<N>>> Transaction<'a, N, T> {
    pub fn add(&self, key: &str, val: &T) -> Result<(), ConflictableTransactionError<Error>> {
        trace!("Adding `{key}` to the {} database", type_name::<T>());

        self.0.insert(key, serialize(val)?)?;

        Ok(())
    }

    pub fn get(
        &self,
        key: &str,
    ) -> Result<Option<Archived<T>>, ConflictableTransactionError<Error>> {
        trace!("Getting `{key}` from the {} database", type_name::<T>());

        match self.0.get(key).map_err(Error::unexpected)? {
            Some(v) => Ok(Some(Archived::deserialize(v)?)),
            None => Ok(None),
        }
    }

    pub fn delete(
        &self,
        key: &str,
    ) -> Result<Option<Archived<T>>, ConflictableTransactionError<Error>> {
        trace!("Deleting {key} from the {} database", type_name::<T>());

        match self.0.remove(key).map_err(Error::unexpected)? {
            Some(v) => Ok(Some(Archived::deserialize(v)?)),
            None => Ok(None),
        }
    }

    pub fn generate_id(&self) -> Result<u64, ConflictableTransactionError<Error>> {
        self.0.generate_id().map_err(|e| e.into())
    }
}
