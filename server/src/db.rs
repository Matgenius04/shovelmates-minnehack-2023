use std::error::Error;
use std::ops::Deref;
use std::{any::type_name, marker::PhantomData, sync::Arc};

use anyhow::anyhow;
use log::{info, trace};
use ouroboros::self_referencing;
use rkyv::ser::serializers::AllocSerializer;
use rkyv::{Archive, Deserialize, Fallible};
use sha3::Digest;
use sled::{
    transaction::{ConflictableTransactionError, TransactionError},
    IVec,
};

pub struct Db<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive>(
    Arc<sled::Db>,
    PhantomData<T>,
);

impl<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive> Clone for Db<N, T> {
    fn clone(&self) -> Self {
        Db(Arc::clone(&self.0), PhantomData)
    }
}

fn serialize<const N: usize, T: rkyv::Serialize<AllocSerializer<N>>>(
    v: &T,
) -> Result<IVec, anyhow::Error> {
    let mut serialized = rkyv::to_bytes(v)?;
    serialized.extend_from_slice(&sha3::Sha3_256::digest(&serialized));

    Ok(IVec::from(&*serialized))
}

#[self_referencing]
pub struct Archived<T: Archive>
where
    T::Archived: 'static,
{
    bytes: IVec,
    // I think ouroboros removes `data` from the declaration
    phantom: PhantomData<T>,
    #[borrows(bytes)]
    data: &'this T::Archived,
}

impl<T: Archive> Deref for Archived<T>
where
    T::Archived: 'static,
{
    type Target = T::Archived;

    fn deref(&self) -> &T::Archived {
        *self.borrow_data()
    }
}

impl<T: Archive> Archived<T>
where
    T::Archived: 'static,
{
    fn deserialize(bytes: IVec) -> Result<Self, anyhow::Error> {
        Archived::try_new(bytes, PhantomData, |bytes| {
            let len = bytes.len();
            let hash = bytes
                .get((len - 256)..len)
                .ok_or_else(|| anyhow!("The data in storage is too short to contain a hash"))?;
            let data = bytes
                .get(0..(len - 264))
                .ok_or_else(|| anyhow!("The data in storage is too short to contain the data"))?;

            if hash != &*sha3::Sha3_256::digest(data) {
                return Err(anyhow::Error::msg("The hash doesn't match the data"));
            }

            // SAFETY: The data was validated using sha3. This would break if the data was generated by something other than the `serialize` function above, I don't think that's likely
            Ok(unsafe { rkyv::util::archived_root::<T>(data) })
        })
    }

    pub fn to_original_with<D: Fallible + ?Sized>(&self, de: &mut D) -> Result<T, D::Error>
    where
        T::Archived: Deserialize<T, D>,
    {
        self.deref().deserialize(de)
    }

    pub fn to_original(&self) -> T
    where
        T::Archived: Deserialize<T, rkyv::Infallible>,
    {
        self.deref().deserialize(&mut rkyv::Infallible).unwrap()
    }
}

impl<const N: usize, T: rkyv::Serialize<AllocSerializer<N>> + Archive> Db<N, T> {
    pub fn open(string: &str) -> Db<N, T> {
        info!("Opening {} DB from {string}", type_name::<T>());

        Db(
            Arc::new(sled::open(string).expect("the database to be available")),
            PhantomData,
        )
    }

    pub fn contains(&self, key: &str) -> Result<bool, anyhow::Error> {
        trace!("Checking if {key} exists in {} database", type_name::<T>());

        Ok(self.0.contains_key(key)?)
    }

    pub fn add(&self, key: &str, val: &T) -> Result<(), anyhow::Error> {
        trace!("Adding `{key}` to the {} database", type_name::<T>());

        self.0.insert(key, serialize(val)?)?;

        Ok(())
    }

    pub fn get(&self, key: &str) -> Result<Option<Archived<T>>, anyhow::Error> {
        trace!("Getting `{key}` from the {} database", type_name::<T>());

        match self.0.get(key)? {
            Some(v) => Ok(Some(Archived::deserialize(v)?)),
            None => Ok(None),
        }
    }

    pub fn delete(&self, key: &str) -> Result<Option<Archived<T>>, anyhow::Error> {
        trace!("Deleting {key} from the {} database", type_name::<T>());

        match self.0.remove(key)? {
            Some(v) => Ok(Some(Archived::deserialize(v)?)),
            None => Ok(None),
        }
    }

    pub fn iter(&self) -> impl Iterator<Item = Result<(String, Archived<T>), anyhow::Error>> {
        trace!("Iterating the {} database", type_name::<T>());

        self.0.iter().map(|maybe_v| {
            let (key, val) = maybe_v?;

            let str = String::from_utf8(key.to_vec())?;
            let t = Archived::deserialize(val)?;

            Ok((str, t))
        })
    }

    pub fn update<D: Fallible + Default + ?Sized, A>(
        &self,
        key: &str,
        f: impl Fn(&mut T) -> A,
    ) -> Result<Option<A>, anyhow::Error>
    where
        T::Archived: Deserialize<T, D> + 'static,
        D::Error: Error + Send + Sync,
    {
        trace!("Updating {key} in the {} database", type_name::<T>());

        self.0
            .transaction(|tree| {
                let mut de = D::default();

                let mut v = match tree.get(key)? {
                    Some(v) => Archived::<T>::deserialize(v)
                        .map_err(|e| {
                            ConflictableTransactionError::<anyhow::Error>::Abort(e.into())
                        })?
                        .to_original_with(&mut de)
                        .map_err(|e| {
                            ConflictableTransactionError::<anyhow::Error>::Abort(e.into())
                        })?,
                    None => return Ok(None),
                };

                let a = f(&mut v);

                tree.insert(
                    key,
                    serialize(&v).map_err(|e| ConflictableTransactionError::Abort(e.into()))?,
                )?;

                Ok(Some(a))
            })
            .map_err(|e| match e {
                TransactionError::Abort(e) => e,
                TransactionError::Storage(e) => e.into(),
            })
    }
}
